#!/usr/bin/env python3
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('host', nargs='?', default='localhost')
parser.add_argument('port', nargs='?', default=8000, type=int)
args = parser.parse_args()

import telnetlib
tn = telnetlib.Telnet(args.host, args.port)
tn.set_debuglevel(3)

from Crypto.Util.number import *
import ast
import itertools

import mt19937predictor  # https://github.com/kmyk/mersenne-twister-predictor
predictor = mt19937predictor.MT19937Predictor()
predicted = False

while True:
    # recv doors
    n = [ None ] * 3
    c = [ None ] * 3
    for i in range(3):
        tn.read_until(b'\xf0\x9f\x94\x92')
        tn.read_until(b'. ')
        n[i], e, c[i] = ast.literal_eval(tn.read_until(b'\n').decode())

    if not predicted:
        # send choice
        tn.read_until(b'>>> ')
        tn.write(b'1\n')

        # recv keys
        d = [ None ] * 3
        padding = [ None ] * 3
        for i in range(3):
            tn.read_until(b'\xf0\x9f\x94\x91')
            tn.read_until(b'. ')
            d[i] = int(tn.read_until(b'\n').decode())
            for j in range(3):
                m = long_to_bytes(pow(c[j], d[i], n[j]))
                if b'WIN' in m or b'LOSE' in m:
                    print('[*]', m[: m.index(b' ') + 5].decode())
                    padding[i] = bytes_to_long(m[m.index(b' ') + 5 : ])
            print('[*] padding', padding[i])

        # predict PRNG
        state = predictor.getstate()
        if predictor.getrandbits(200 * 8) == padding[0]:
            predicted = True
            predictor.getrandbits(200 * 8)
            predictor.getrandbits(200 * 8)
        else:
            predictor.setstate(state)
            for i in range(3):
                predictor.setrandbits(padding[i], 200 * 8)

    else:
        # find the answer
        answer = None
        for j in range(3):
            padding = predictor.getrandbits(200 * 8).to_bytes(200, 'big')
            m = bytes_to_long(b'WIN \xf0\x9f\x92\x8e' + padding)
            for i in range(3):
                if c[i] == pow(m, e, n[i]):
                    answer = i
        assert answer is not None

        # send the choice
        tn.read_until(b'>>> ')
        tn.write(b'%d\n' % (answer + 1))

        tn.read_until(b'you win')
